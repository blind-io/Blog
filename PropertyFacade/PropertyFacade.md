title: template<method> template
subtile: making a property-facade by overriding equals.



# template < method > template

I was searching for a way to make objects that were adapters to values obtained through a COM interface behave a bit like they were normal values. i.e. I want to type things like 

        property = value;
and

        value = *property;

where `operator=` acts as a setter and `operator*` as the getter. I discovered that this is much harder than it looks. Sure I could just make a `Set()` and `Value()` method and be done with it but that's a defeatist attitude! Why was it hard? Templates.

The properties I want to retrieve and set can be longs, doubles, CStrings, enums and other more complex objects. Templates to the rescue. Effectively I want a template that uses the template method pattern. Turns out you can't really just do that.

~~~~~~~~~~~~~~~~
template<class T>
class IPropertyFacade

    virtual T Value() = 0;
    virtual void Set(T value) = 0;
public:
    T operator*() {return Value()};
    void operator=(T value) {Set(value)};
~~~~~~~~~~~~~~~~

Just extend this class an override the `Set()` and `Value()` methods and all my `=` and `*` operators will redirect, right?

# Ambiguious  equals

My API supports most of the types I want to use with overloaded methods so theres not a lot of work to do here. Create a templated call and then typdef for shorthand.

~~~~~~~~~~~~~~~~~~~~~~~~~
template<class T> 
class CProperty : IPropertyFacade<T>

//this disambiguates the operator = generated by the compiler, Ugly!
using IPropertyFacade<T>::operator=

T Value() override{
    return API_GETTER<T>();
};
void Set(T value){
    API_SETTER(value)
};

//typdefs for shorthand - allows for a consistent naming convention when objects are made differently.
typedef CProperty<double> CProperty_Double;
typedef CProperty<CString> CProperty_String;
typedef CProperty<long> CProperty_Long;

//you have to use the template to check it compiles
class TestObject
{
    TestObject()
    : double_prop()
    
    CProperty_Double m_double_prop;

    void Test()
    {
        double num = *m_double_prop;
        m_double_prop = 3.37;
    }
}
~~~~~~~~~~~~~~~~~~~~~~~~~

With the using operator= line this compiles. Its ugly but i'm not going to respecify the overloads in every class I write because I'm using template method and *that's the whole point*.
I went merrily ahead and created a bunch of other more specialised property classes. I found a problem when I actually tried to run it. 

# Pure Virtual Function Call

Turns out that you can't mix virtual functions and templates. Naievly you would think that's ok. Cut and paste `double` over `T` and everything should work. People who write compilers disagree and say this is not allowed. Spoilsports. 

What actually happens is that when `=` or even `Set()` are called it calls the pure virtual function in `IPropertyFacade`. I'm actually surprised that this even compiles if that's the case. Simply deleting `IPropertyFacade` and giving up on the whole `=` syntax and using `Set()` instead works perfectly well. With a bit of extra efort the `=` and `*` overloads can be specified explicitly everywhere they are needed. 

Any sensible person would do one of these two things. Sensible people are weak. 

# Policy-Based Design

The solution is to use [Policy Based Design]("https://en.wikipedia.org/wiki/Policy-based_design").
<!--
template <typename OutputPolicy, typename LanguagePolicy>
class HelloWorld : private OutputPolicy, private LanguagePolicy
{
    using OutputPolicy::print;
    using LanguagePolicy::message;
 
public:
    // Behaviour method
    void run() const
    {
        // Two policy methods
        print(message());
    }
};
-->

Normally two template parameters are used for policy based design but here we only need one. Instead of inheriting from the template method class we flip the inheritence on its head and the template method class inherits from the behaviour. No virtual function calls mean no template inheritance, solving the annoying no virtual template function rule. 

~~~~~~~~~~~~~~~~
template<class PropertyType>
class IPropertyFacade: PropertyType
    //constructor argument forwarding ommited for brevity.

public:
    T operator*() {return Value()};
    void operator=(T value) {Set(value)};

//typdefs for shorthand 
typedef IPropertyFacade<CProperty<double>> CProperty_Double;
typedef IPropertyFacade<CProperty<CString>> CProperty_String;
typedef IPropertyFacade<CProperty<long>> CProperty_Long;
~~~~~~~~~~~~~~~~

The IPropertyFacade is now a magical template that imbues the class with magical operator overloading. 

Effectively the answer is you can't use the template method pattern with templates but you *can* use the strategy pattern. 

